use std::collections::HashMap;
use std::error::Error;
use std::fs::File;
use std::io::Write;
use std::path::Path;

use new_string_template::template::Template;

static INFOMEM_LINKER_SCRIPT_TEMPLATE: &str = r#"
{header}

SECTIONS {
    .info : {
        _sinfo = .;
        KEEP(*({info_section_name}))
        _einfo = .;
    } {memory_region} {insert_before_after}
}

{footer}
"#;

static INFOMEM_LINKER_SCRIPT_FOOTER_TEMPLATE: &str = r#"
ASSERT((_einfo - _sinfo) <= {max_safe_info_size}, "
ERROR({filename}): Information memory output section is greater than {max_safe_info_size} bytes long.
Flashing may overwrite important calibration data. The link has stopped as a precaution.
");
"#;

struct LdConfigInternal<'a> {
    inp_section: &'a str,
    region: Option<&'a str>,
    insert: InsertType<'a>,
    max_size: Option<usize>,
}

impl<'a> Default for LdConfigInternal<'a> {
    fn default() -> Self {
        Self {
            inp_section: ".info",
            region: None,
            insert: InsertType::None,
            max_size: None,
        }
    }
}

pub struct LdConfig<'a>(LdConfigInternal<'a>);

pub enum InsertType<'a> {
    None,
    Before(&'a str),
    After(&'a str),
}

impl<'a> Default for LdConfig<'a> {
    fn default() -> Self {
        Self(Default::default())
    }
}

impl<'a> LdConfig<'a> {
    pub fn msp430() -> Self {
        Self(LdConfigInternal {
            region: Some("INFOMEM"),
            max_size: Some(192),
            ..Default::default()
        })
    }

    pub fn input_section(mut self, sec: &'a str) -> Self {
        self.0.inp_section = sec;
        self
    }

    pub fn region(mut self, reg: Option<&'a str>) -> Self {
        self.0.region = reg;
        self
    }

    pub fn insert(mut self, ins: InsertType<'a>) -> Self {
        self.0.insert = ins;
        self
    }

    pub fn max_size(mut self, size: Option<usize>) -> Self {
        self.0.max_size = size;
        self
    }
}

pub fn generate_infomem_ldscript<P>(path: P, cfg: LdConfig) -> Result<(), Box<dyn Error>>
where
    P: AsRef<Path>,
{
    let filename = path
        .as_ref()
        .file_name()
        .ok_or("invalid filename for linker script")?
        .to_string_lossy();
    let dir = path
        .as_ref()
        .parent()
        .ok_or("invalid path for linker script")?
        .to_string_lossy();
    let script = generate_script(cfg, &filename)?;
    let mut fp = File::create(&path)?;
    fp.write_all(&script.as_bytes())?;

    println!("cargo:rustc-link-arg=-T{}", filename);
    println!("cargo:rustc-link-search={}", dir);

    Ok(())
}

fn generate_script(cfg: LdConfig, filename: &str) -> Result<String, Box<dyn Error>> {
    let templ = Template::new(INFOMEM_LINKER_SCRIPT_TEMPLATE);

    let mut data: HashMap<&str, String> = HashMap::new();
    generate_header(&mut data);
    generate_body(&mut data, &cfg.0);
    generate_footer(&mut data, &cfg.0, filename)?;

    Ok(templ.render(&data)?)
}

fn generate_header(data: &mut HashMap<&str, String>) {
    data.insert(
        "header",
        concat!(
            "/* Generated by ",
            env!("CARGO_PKG_NAME"),
            " version ",
            env!("CARGO_PKG_VERSION"),
            " */"
        )
        .into(),
    );
}

fn generate_body<'a>(data: &mut HashMap<&str, String>, cfg: &LdConfigInternal<'a>) {
    data.insert("info_section_name", cfg.inp_section.into());

    match cfg.region {
        None => data.insert("memory_region", "".into()),
        Some(s) => data.insert("memory_region", "> ".to_owned() + s),
    };

    match cfg.insert {
        InsertType::None => data.insert("insert_before_after", "".into()),
        InsertType::Before(s) => {
            data.insert("insert_before_after", "INSERT BEFORE ".to_owned() + s)
        }
        InsertType::After(s) => data.insert("insert_before_after", "INSERT AFTER ".to_owned() + s),
    };
}

fn generate_footer<'a>(
    data: &mut HashMap<&str, String>,
    cfg: &LdConfigInternal<'a>,
    filename: &str,
) -> Result<(), Box<dyn Error>> {
    match cfg.max_size {
        None => {
            data.insert("footer", "".into());
        }
        Some(size) => {
            let footer_templ = Template::new(INFOMEM_LINKER_SCRIPT_FOOTER_TEMPLATE);

            let mut footer_data: HashMap<&str, String> = HashMap::new();
            footer_data.insert("max_safe_info_size", size.to_string());
            footer_data.insert("filename", filename.into());

            let footer = footer_templ.render(&footer_data)?;
            data.insert("footer", footer.into());
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use indoc::indoc;
    use ldscript_parser as lds;

    fn assert_ldscript_eq(left: &str, right: &str) -> Result<(), String> {
        let ldl = lds::parse(left)?;
        let ldr = lds::parse(right)?;

        assert_eq!(ldl, ldr);

        Ok(())
    }

    #[test]
    fn generate_default() {
        let lds = generate_script(LdConfig::default(), "foo.x").unwrap();
        assert_ldscript_eq(
            &lds,
            indoc! {"
                SECTIONS {
                    .info : {
                        _sinfo = .;
                        KEEP(*(.info))
                        _einfo = .;
                    }  
                }
            "},
        )
        .unwrap();
    }

    #[test]
    fn generate_max_with_region() {
        let mut cfg = LdConfig::default();
        cfg.0.region = Some("INFOMEM");
        cfg.0.max_size = Some(192);

        let lds = generate_script(cfg, "foo.x").unwrap();
        assert_ldscript_eq(
            &lds,
            indoc! {"
            SECTIONS {
                .info : {
                    _sinfo = .;
                    KEEP(*(.info))
                    _einfo = .;
                } > INFOMEM 
            }

            ASSERT((_einfo - _sinfo) <= 192, \"
            ERROR(foo.x): Information memory output section is greater than 192 bytes long.
            Flashing may overwrite important calibration data. The link has stopped as a precaution.
            \");
            "},
        )
        .unwrap();
    }
}
